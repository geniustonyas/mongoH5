<template>
  <div class="page video-page">
    <header class="d-header h-video">
      <div class="d-l">
        <a @click="appStore.setBack(true)"><i class="mvfont mv-left" /></a>
      </div>
      <div class="d-m" />
      <div class="d-r" />
    </header>
    <section class="vp-main">
      <div class="vpm-bd">
        <div class="vm-b">
          <swiper
            @on-swiper="onSwiper"
            :direction="'vertical'"
            :modules="modules"
            :virtual="{ slides: videos.length, enabled: true, addSlidesBefore: 5, addSlidesAfter: 5 } as undefined"
            :slides-per-view="1"
            :space-between="0"
            @slide-change="slideChange"
            :initial-slide="initialSlide"
            style="width: 100%; height: 100%"
          >
            <swiper-slide v-for="(video, index) in videos" :key="video.id" :virtual-index="index" :data-video-id="video.id">
              <div class="v-a">
                <video
                  :id="'video-player-' + video.id"
                  class="video-player"
                  :data-poster="video.poster"
                  muted
                  preload="auto"
                  loop
                  x5-video-player-fullscreen="true"
                  x5-playsinline
                  playsinline
                  webkit-playsinline
                  style="width: 100%; height: 100%"
                />
              </div>
              <div class="v-b">
                <a @click="handleLike()">
                  <i :class="['mvfont', 'mv-xihuan', { active: videoDetail && videoDetail.like == 1 }]" />
                  <b>{{ videoDetail ? videoDetail.likeCount : 0 }}</b>
                </a>
                <a @click="handleCollection()">
                  <i :class="['mvfont', 'mv-shoucang', { active: videoDetail && videoDetail.collect }]" />
                  <b>{{ videoDetail ? videoDetail.collectionCount : 0 }}</b>
                </a>
                <a @click="handleShare"><i class="mvfont mv-zhuanfa" /><b>分享</b></a>
                <a class="btn-mute" @click="toggleMute">
                  <i :class="['mvfont', mutePlay ? 'mv-jingyin' : 'mv-shengyin0']" />
                  <span>取消静音</span>
                </a>
              </div>
              <div class="v-c">
                <!-- <div class="c-g">
                  <img :src="getAssetsFile('logo-2.png')" />芒果TV官方
                  <span>{{ appStore.spareData.OfficialDomain }}</span>
                </div> -->
                <h3>
                  @芒果TV官方-
                  <span>{{ appStore.spareData.OfficialDomain }}</span>
                </h3>
                <p>
                  <b>{{ video.title }}</b>
                  <template v-if="videoDetail && videoDetail.tags">
                    <span v-for="tag in videoDetail.tags" :key="tag.id">#{{ tag.title }}</span>
                  </template>
                </p>
              </div>
            </swiper-slide>
          </swiper>
        </div>
      </div>
    </section>
    <Loading v-show="isLoading" />
    <Popup v-model:show="showSharePopup" teleport="body" position="center" :overlay="false" round>
      <div class="share-popup">
        <p>分享链接已复制，赶快去分享给好友吧！</p>
      </div>
    </Popup>
    <Loading v-show="isLoading" />
  </div>
</template>

<script setup lang="ts">
  import { ref, onMounted, nextTick } from 'vue'
  import { onBeforeRouteLeave, useRoute } from 'vue-router'
  import { getVideoListApi, getVideoDetailApi, addPlayCountApi } from '@/api/video'
  import decryptionService from '@/utils/decryptionService'
  import { userLike, userCollection, userCollectionHistory, userWatchHistory } from '@/api/user'
  import type { Video, VideoDetailResponse } from '@/types/video'
  import { useAppStore } from '@/store/app'
  import { useUserStore } from '@/store/user'
  import { generateAuthUrl } from '@/utils/decryptionService'
  import Loading from '@/components/layout/Loading.vue'

  import { Swiper, SwiperSlide } from 'swiper/vue'
  import { Virtual } from 'swiper/modules'
  import 'swiper/css'
  import 'swiper/css/virtual'

  import { Popup, showToast } from 'vant'
  import Clipboard from 'clipboard'

  const appStore = useAppStore()
  const userStore = useUserStore()
  const route = useRoute()

  const modules = [Virtual]
  const decrypt = new decryptionService()

  const videos = ref<Video[]>([])
  const videoDetail = ref<VideoDetailResponse | null>(null)
  const players = ref<Map<string, any>>(new Map())
  const hlsInstances = ref<Map<string, any>>(new Map())
  const currentVideoId = ref(route.query.id ? (route.query.id as string) : '')

  const swiperInstance = ref<any>(null)
  const showSharePopup = ref(false)
  const clipboard = ref<Clipboard | null>(null)
  const isLoading = ref(true)
  const mutePlay = ref(true)

  const playIndex = ref(route.query.playIndex ? Number(route.query.playIndex) : undefined)
  const listType = ref(route.query.listType || 'normal')

  const pageIndex = ref(0)
  const pageSize = 5
  const totalPage = ref(0)
  const initialSlide = ref(3)

  const onSwiper = (swiper: any) => {
    swiperInstance.value = swiper
  }

  const fetchVideos = async (isPrepend = false) => {
    try {
      let newVideos = []
      if (listType.value === 'collect') {
        // 收藏列表
        const {
          data: { data }
        } = await userCollectionHistory({ PageIndex: pageIndex.value, PageSize: pageSize, VideoType: 1 })
        if (data && data.items) {
          newVideos = data.items
          totalPage.value = Number(data.pageCount)
        }
      } else if (listType.value === 'history') {
        // 足迹列表
        const {
          data: { data }
        } = await userWatchHistory({ PageIndex: pageIndex.value, PageSize: pageSize })
        if (data && data.items) {
          newVideos = data.items
          totalPage.value = Number(data.pageCount)
        }
      } else if (listType.value === 'normal') {
        // 从 localStorage 读取视频对象
        const storedVideo = localStorage.getItem('shortPlayVideo')
        if (storedVideo) {
          try {
            const video = JSON.parse(storedVideo) as Video
            videos.value.push(video)
          } catch (error) {
            console.error('解析本地存储视频失败:', error)
          }
        }
        // 调用随机视频接口
        const {
          data: { data }
        } = await getVideoListApi({ PageIndex: pageIndex.value, PageSize: pageSize, VideoType: 1, SortType: 1 })
        if (data && data.items) {
          newVideos = data.items
          totalPage.value = Number(data.pageCount)
        }
      }
      // 上划和下滑分别插入到头部和尾部
      if (isPrepend) {
        videos.value.unshift(...newVideos)
      } else {
        videos.value.push(...newVideos)
      }
    } catch (error) {
      console.error('获取视频列表失败:', error)
    }
  }

  const fetchVideoDetail = async (videoId: number) => {
    try {
      const {
        data: { data }
      } = await getVideoDetailApi(videoId)
      videoDetail.value = data
    } catch (error) {
      console.error('获取视频详情失败:', error)
    }
  }

  const initializePlayer = async (videoId: string) => {
    await nextTick() // 确保 DOM 已更新
    const videoIndex = videos.value.findIndex(video => video.id == videoId)
    if (videoIndex == -1) return
    const videoElement = document.getElementById('video-player-' + videoId) as HTMLVideoElement
    if (!videoElement) {
      console.error(`Video element with id 'video-player-${videoId}' not found`)
      return
    }
    if (players.value.has(videoId)) {
      players.value.get(videoId).destroy()
      players.value.delete(videoId)
    }
    if (hlsInstances.value.has(videoId)) {
      hlsInstances.value.get(videoId).stopLoad()
      hlsInstances.value.get(videoId).destroy()
      hlsInstances.value.delete(videoId)
    }

    const url = generateAuthUrl(appStore.playDomain, videos.value[videoIndex].playUrl)
    if (window.Hls.isSupported()) {
      try {
        const player = new window.Plyr(videoElement, {
          clickToPlay: true,
          autoplay: false,
          muted: true,
          autopause: true,
          hideControls: true,
          controls: ['progress']
        })
        // 播放器初始化后总是把禁音给取消了, 这里重新设置
        player.muted = mutePlay.value
        const hls = new window.Hls({
          maxBufferLength: 15,
          maxMaxBufferLength: 30,
          maxBufferSize: 30 * 1000 * 1000,
          maxBufferHole: 0.2,
          startFragPrefetch: true,
          liveSyncDuration: 3,
          liveMaxLatencyDuration: 5
        })
        // hls.config.xhrSetup = (xhr) => {
        //   const tsUrlWithAuth = generateAuthUrl(appStore.playDomain, video.playUrl)
        //   xhr.open('GET', tsUrlWithAuth, true)
        // }
        hlsInstances.value.set(videoId, hls)
        hls.loadSource(url)
        hls.attachMedia(videoElement)

        // 点击屏幕播放暂停
        hls.on(window.Hls.Events.MANIFEST_PARSED, () => {
          player.on('click', event => {
            if (player.touch && event.target.className == 'plyr__poster') {
              player.togglePlay()
            }
          })

          // 播放一次添加播放量
          player.once('play', async () => {
            await addPlayCountApi(videoDetail.value?.id)
          })

          // 如果不是当前视频，则暂停
          player.on('play', () => {
            isLoading.value = false
          })
        })

        // hls错误处理
        hls.on(window.Hls.Events.ERROR, (event, data) => {
          if (data.fatal) {
            handleHlsError(data, hls)
          }
        })

        // 可以播放时，获取视频宽高，判断是否需要添加cover-fit
        player.on('canplay', () => {
          const videoWidth = videoElement.videoWidth
          const videoHeight = videoElement.videoHeight
          const videoRatio = videoHeight / videoWidth
          if (videoRatio > 1.5) {
            videoElement.classList.add('cover-fit')
          }
          if (currentVideoId.value == videoId) {
            isLoading.value = false
          }
        })
        players.value.set(videoId, player)
      } catch (error) {
        console.error('初始化hls失败: ' + videoId, error)
      }
    } else if (videoElement.canPlayType('application/vnd.apple.mpegurl')) {
      videoElement.src = url
      const player = new window.Plyr(videoElement, {
        clickToPlay: true,
        autoplay: false,
        muted: true,
        autopause: true,
        hideControls: true,
        controls: ['progress']
      })
      // 播放器初始化后总是把禁音给取消了, 这里重新设置
      player.muted = mutePlay.value
      player.on('canplay', () => {
        const videoWidth = videoElement.videoWidth
        const videoHeight = videoElement.videoHeight
        const videoRatio = videoHeight / videoWidth
        if (videoRatio > 1.5) {
          videoElement.classList.add('cover-fit')
        }
        if (currentVideoId.value == videoId) {
          isLoading.value = false
        }
      })
      players.value.set(videoId, player)
    } else {
      console.error('HLS not supported and cannot play type')
    }
  }

  const handleHlsError = (data, hls) => {
    switch (data.type) {
      case window.Hls.ErrorTypes.NETWORK_ERROR:
        console.error('HLS network error:', data)
        hls.startLoad()
        break
      case window.Hls.ErrorTypes.MEDIA_ERROR:
        console.error('HLS media error:', data)
        hls.recoverMediaError()
        break
      case window.Hls.ErrorTypes.OTHER_ERROR:
        console.error('HLS other error:', data)
        break
      default:
        console.error('HLS unrecoverable error:', data)
        // showToast('播放失败')
        // hls.destroy()
        // hls.stopLoad()
        // hlsInstances.value.delete(index)
        break
    }
  }

  let previousIndex = 0 // 用于记录上一个索引
  const slideChange = async swiper => {
    try {
      const currentIndex = swiper.activeIndex
      const previousVideoId = currentVideoId.value
      const currentSlide = swiper.slides[currentIndex]
      if (!currentSlide) return

      // 更新当前视频id
      currentVideoId.value = currentSlide.dataset.videoId
      console.log('上一个: ' + previousVideoId, '当前: ' + currentVideoId.value)
      if (previousVideoId === currentVideoId.value) return

      // 播放当前视频
      await playCurrentVideo()
      // 停止并重置上一个视频
      await stopAndResetVideo(previousVideoId)
      // 判断上划还是下滑
      const isSlidingDown = currentIndex > previousIndex
      previousIndex = currentIndex

      const videoIndex = videos.value.findIndex(video => video.id == currentVideoId.value)
      const nextVideoId = isSlidingDown ? videos.value[videoIndex + 1].id : videos.value[videoIndex - 1].id
      if (nextVideoId) {
        await initializePlayer(nextVideoId)
      }
      // 销毁上上一个视频
      const destroyVideoId = isSlidingDown ? videos.value[videoIndex - 2].id : videos.value[videoIndex + 2].id
      if (destroyVideoId && players.value.has(destroyVideoId)) {
        await destroyVideo(destroyVideoId)
        console.log('上上一个视频销毁完成', destroyVideoId)
      }

      // 获取视频详情
      const currentVideo = videos.value[videoIndex]
      if (currentVideo) {
        await fetchVideoDetail(parseInt(currentVideo.id))
      }

      // 上划加载下面的数据
      if (isSlidingDown && videos.value.length - videoIndex < 3) {
        if (pageIndex.value < totalPage.value) {
          pageIndex.value++
          await fetchVideos()
        }
      } else if (!isSlidingDown && videoIndex < 2) {
        if (pageIndex.value > 1) {
          pageIndex.value--
          await fetchVideos()
        }
      }
    } catch (error) {
      console.error('滑动失败:', error)
    }
  }

  const stopAndResetVideo = videoId => {
    const player = players.value.get(videoId)
    if (hlsInstances.value.has(videoId)) {
      console.log('stopload: ' + videoId)
      hlsInstances.value.get(videoId).stopLoad()
    }
    if (player) {
      try {
        console.log('stop: ' + videoId)
        if (currentVideoId.value != videoId) {
          player.stop()
          console.log('播放器已停止: ' + videoId)
        }
      } catch (error) {
        console.error('停止播放失败:', error)
      }
    }
  }

  const playCurrentVideo = async () => {
    isLoading.value = true
    const currentPlayer = players.value.get(currentVideoId.value)
    if (!currentPlayer) {
      console.log('播放器不存在，初始化: ' + currentVideoId.value)
      await initializePlayer(currentVideoId.value)
      return
    }

    const videoElement = currentPlayer.media
    if (!videoElement) {
      console.error('Video element is null')
      return
    }

    const playVideo = async () => {
      console.log('playVideo 方法被调用')
      try {
        console.log('播放器 ' + currentVideoId.value + ' 存在，播放')
        await currentPlayer.play()
      } catch (error) {
        if (error.name == 'NotAllowedError') {
          showToast('点击屏幕继续播放')
        }
      } finally {
        isLoading.value = false
      }
    }

    if (videoElement.readyState >= 2) {
      console.log('视频成功播放')
      await playVideo()
    } else {
      console.log('播放器: ' + currentVideoId.value + ' 视频未准备好')
      videoElement.addEventListener(
        'canplay',
        async function onCanPlay() {
          await playVideo()
          videoElement.removeEventListener('canplay', onCanPlay)
        },
        { once: true }
      )
    }
  }

  const destroyVideo = async videoId => {
    const playerToDestroy = players.value.get(videoId)
    await playerToDestroy.stop()
    await playerToDestroy.destroy()
    playerToDestroy.currentTime = 0
    if (hlsInstances.value.has(videoId)) {
      hlsInstances.value.get(videoId).stopLoad()
      hlsInstances.value.get(videoId).destroy()
      hlsInstances.value.delete(videoId)
    }
    players.value.delete(videoId)
  }

  const checkLogin = (): boolean => {
    if (userStore.userInfo.id == '') {
      userStore.showLoginDialog = true
      return false
    }
    return true
  }

  const handleLike = async () => {
    if (!checkLogin()) return

    try {
      const videoId = videoDetail.value?.id
      const newLikeStatus = videoDetail.value?.like == 1 ? 0 : 1

      await userLike({ VideoId: videoId, Like: newLikeStatus })

      videoDetail.value.like = newLikeStatus
      videoDetail.value.likeCount = (Number(videoDetail.value.likeCount) + (newLikeStatus ? 1 : -1)).toString()
    } catch (error) {
      console.error('操作失败:', error)
    }
  }

  const handleCollection = async () => {
    if (!checkLogin()) return

    try {
      const videoId = videoDetail.value?.id
      const newCollectStatus = !videoDetail.value?.collect

      await userCollection({ VideoId: videoId, Collect: newCollectStatus })

      videoDetail.value.collect = newCollectStatus
      videoDetail.value.collectionCount = (Number(videoDetail.value.collectionCount) + (newCollectStatus ? 1 : -1)).toString()
    } catch (error) {
      console.error('操作失败:', error)
    }
  }

  const handleShare = () => {
    if (clipboard.value) {
      clipboard.value.destroy()
    }
    clipboard.value = new Clipboard('.share-button', {
      text: () => window.location.href
    })

    clipboard.value?.on('success', () => {
      showSharePopup.value = true
      setTimeout(() => {
        showSharePopup.value = false
      }, 2000)
      clipboard.value?.destroy()
    })

    clipboard.value?.on('error', () => {
      console.error('复制失败')
      clipboard.value?.destroy()
    })

    const button = document.createElement('button')
    button.className = 'share-button'
    document.body.appendChild(button)
    button.click()
    document.body.removeChild(button)
  }

  const toggleMute = () => {
    mutePlay.value = !mutePlay.value
    players.value.forEach(player => {
      player.muted = mutePlay.value
    })
  }

  ;(async () => {
    if (playIndex.value !== undefined && currentVideoId.value) {
      initialSlide.value = playIndex.value % pageSize
    }
  })()

  onMounted(async () => {
    if (playIndex.value !== undefined && currentVideoId.value) {
      pageIndex.value = Math.floor(playIndex.value / pageSize) + 1
      await fetchVideos()
      const index = videos.value.findIndex(video => video.id == currentVideoId.value)
      if (index != -1) {
        await initializePlayer(currentVideoId.value)
        // 预加载上一个和下一个视频
        if (videos.value[index - 1]) {
          await initializePlayer(videos.value[index - 1].id)
        }
        if (videos.value[index + 1]) {
          await initializePlayer(videos.value[index + 1].id)
        }
      } else {
        showToast('视频未找到')
      }
    } else {
      const randomPageIndex = Math.floor(Math.random() * (appStore.shortVideoRandomMax - appStore.shortVideoRandomMin + 1)) + appStore.shortVideoRandomMin
      pageIndex.value = randomPageIndex
      await fetchVideos()
    }
  })

  onBeforeRouteLeave(() => {
    players.value.forEach(player => {
      player.destroy()
    })
    hlsInstances.value.forEach(hls => {
      hls.stopLoad()
      hls.destroy()
    })
    players.value.clear()
    hlsInstances.value.clear()
    localStorage.removeItem('plyr')
  })
</script>

<style scoped>
  .active {
    color: #ff6b6b;
  }
  .vp-main .vpm-bd {
    height: calc(100vh - 4.8rem + env(safe-area-inset-bottom));
  }
</style>
